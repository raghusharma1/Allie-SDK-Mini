# ********RoostGPT********
"""
Test generated by RoostGPT for test RaghuTestAllie1 using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=__post_init___bc34ceb59b
ROOST_METHOD_SIG_HASH=__post_init___4c025a599a


Scenario 1: Validate the conversion of string timestamps to datetime objects
Details:
  TestName: test_post_init_timestamp_conversion
  Description: This test verifies that the __post_init__ method correctly converts string timestamps into datetime objects.
Execution:
  Arrange: Initialize objects with string timestamps for 'created_at' and 'token_expires_at'.
  Act: Invoke the __post_init__ method on the objects.
  Assert: Check if the 'created_at' and 'token_expires_at' attributes are now datetime objects.
Validation:
  This test is important to ensure that the string timestamps are correctly converted into datetime objects. This is crucial for the correct functioning of the system as datetime objects are easier to manipulate and compare than string timestamps.

Scenario 2: Validate the preservation of datetime objects
Details:
  TestName: test_post_init_datetime_preservation
  Description: This test verifies that the __post_init__ method does not alter datetime objects.
Execution:
  Arrange: Initialize objects with datetime objects for 'created_at' and 'token_expires_at'.
  Act: Invoke the __post_init__ method on the objects.
  Assert: Check if the 'created_at' and 'token_expires_at' attributes remain the same datetime objects.
Validation:
  This test is important to ensure that the __post_init__ method does not inadvertently alter datetime objects. This is important as the system relies on the accurate representation of these timestamps.

Scenario 3: Validate the functioning with mixed timestamp types
Details:
  TestName: test_post_init_mixed_timestamps
  Description: This test verifies that the __post_init__ method correctly handles a mix of string and datetime timestamps.
Execution:
  Arrange: Initialize objects with 'created_at' as a string timestamp and 'token_expires_at' as a datetime object.
  Act: Invoke the __post_init__ method on the objects.
  Assert: Check if the 'created_at' attribute is now a datetime object and 'token_expires_at' remains the same datetime object.
Validation:
  This test is crucial to ensure that the __post_init__ method can handle a mix of timestamp types. It is possible that the timestamps could be provided in different formats, and the system needs to be able to handle this.
"""

# ********RoostGPT********
import pytest
from datetime import datetime
from authentication_model import AccessToken

class Test_AccessTokenPostInit:

    @pytest.mark.positive
    def test_post_init_timestamp_conversion(self):
        # Arrange
        obj = AccessToken(created_at='2022-01-01T00:00:00Z', token_expires_at='2022-12-31T23:59:59Z')
        # Act
        obj.__post_init__()
        # Assert
        assert isinstance(obj.created_at, datetime)
        assert isinstance(obj.token_expires_at, datetime)

    @pytest.mark.positive
    def test_post_init_datetime_preservation(self):
        # Arrange
        obj = AccessToken(created_at=datetime(2022, 1, 1), token_expires_at=datetime(2022, 12, 31, 23, 59, 59))
        # Act
        obj.__post_init__()
        # Assert
        assert obj.created_at == datetime(2022, 1, 1)
        assert obj.token_expires_at == datetime(2022, 12, 31, 23, 59, 59)

    @pytest.mark.positive
    def test_post_init_mixed_timestamps(self):
        # Arrange
        obj = AccessToken(created_at='2022-01-01T00:00:00Z', token_expires_at=datetime(2022, 12, 31, 23, 59, 59))
        # Act
        obj.__post_init__()
        # Assert
        assert isinstance(obj.created_at, datetime)
        assert obj.token_expires_at == datetime(2022, 12, 31, 23, 59, 59)
