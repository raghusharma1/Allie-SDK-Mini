# ********RoostGPT********
"""
Test generated by RoostGPT for test RaghuTestAllie1 using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=validate_rest_payload_551476b4d5
ROOST_METHOD_SIG_HASH=validate_rest_payload_cbc19b7cf9


Scenario 1: Validating correct payload type
Details:
  TestName: test_validate_payload_correct_type
  Description: This test is intended to verify that the function validate_rest_payload successfully validates payload objects of the expected type without raising an exception.
Execution:
  Arrange: Initialize a list of payload objects of the expected dataclass type.
  Act: Call the validate_rest_payload function with the list of payload objects and the tuple of expected types.
  Assert: Check that no exceptions are raised.
Validation:
  This test ensures that the function correctly identifies and validates payload objects of the expected type. This is crucial because the function's primary purpose is to validate the payload against a set of expected types.

Scenario 2: Validating incorrect payload type
Details:
  TestName: test_validate_payload_incorrect_type
  Description: This test is intended to verify that the function validate_rest_payload raises an UnsupportedPostBody exception when payload objects of an unexpected type are present.
Execution:
  Arrange: Initialize a list of payload objects, including at least one object of a type not included in the expected types.
  Act: Call the validate_rest_payload function with the list of payload objects and the tuple of expected types.
  Assert: Check that an UnsupportedPostBody exception is raised.
Validation:
  This test ensures that the function correctly identifies and rejects payload objects of an unexpected type, raising an appropriate exception. This is important for maintaining the integrity of the API calls, as it prevents the passing of invalid data.

Scenario 3: Validating empty payload
Details:
  TestName: test_validate_payload_empty
  Description: This test is intended to verify that the function validate_rest_payload handles an empty payload list without raising an exception.
Execution:
  Arrange: Initialize an empty list of payload objects.
  Act: Call the validate_rest_payload function with the empty list and any tuple of expected types.
  Assert: Check that no exceptions are raised.
Validation:
  This test ensures that the function can handle an empty payload list, which could occur in certain business scenarios, without raising an exception.

Scenario 4: Validating payload with multiple correct types
Details:
  TestName: test_validate_payload_multiple_types
  Description: This test is intended to verify that the function validate_rest_payload successfully validates payload objects of multiple expected types without raising an exception.
Execution:
  Arrange: Initialize a list of payload objects of multiple types included in the expected types.
  Act: Call the validate_rest_payload function with the list of payload objects and the tuple of expected types.
  Assert: Check that no exceptions are raised.
Validation:
  This test ensures that the function correctly identifies and validates payload objects of multiple expected types. This is crucial in scenarios where the payload can consist of objects of different types.
"""

# ********RoostGPT********
import pytest
from core.custom_exceptions import validate_rest_payload, UnsupportedPostBody

class Test_CustomExceptionsValidateRestPayload:

    def test_validate_payload_correct_type(self):
        # Arrange
        class MockType1:
            pass

        payload = [MockType1(), MockType1()]

        # Act & Assert
        try:
            validate_rest_payload(payload, (MockType1,))
        except Exception:
            pytest.fail("Unexpected Exception ..!")

    def test_validate_payload_incorrect_type(self):
        # Arrange
        class MockType1:
            pass

        class MockType2:
            pass

        payload = [MockType1(), MockType2()]

        # Act & Assert
        with pytest.raises(UnsupportedPostBody):
            validate_rest_payload(payload, (MockType1,))

    def test_validate_payload_empty(self):
        # Arrange
        class MockType1:
            pass

        payload = []

        # Act & Assert
        try:
            validate_rest_payload(payload, (MockType1,))
        except Exception:
            pytest.fail("Unexpected Exception ..!")

    def test_validate_payload_multiple_types(self):
        # Arrange
        class MockType1:
            pass

        class MockType2:
            pass

        payload = [MockType1(), MockType2()]

        # Act & Assert
        try:
            validate_rest_payload(payload, (MockType1, MockType2))
        except Exception:
            pytest.fail("Unexpected Exception ..!")
